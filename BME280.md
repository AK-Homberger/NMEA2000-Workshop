# NMEA2000-Thermometer, Hygrometer und Barometer mit BME280

Das BME280-Modul ist eine Multi-Sensor-Modul das Temperatur, Luftfeute und barometrischen Druck messen kann.
Für die Beispiele mit dem BME280 ist das Steckbrett mit dem BME280-Modul erweitern. Das sollte dann so aussehen:

![Steckbrett mit BME280](https://github.com/AK-Homberger/NMEA-Workshop/blob/main/Bilder/NMEA2000-BME280_Steckplatine.png)

Wir nutzen den BME280 mit dem I2C-Bus. Dazu ist 3,3 Volt, GND und SDA (GPIO 21) und SCL (GPIO 22) zu verbinden. Wenn das verwendete Modul etwas anders aussieht, macht das nichts. Es sind unterschiedliche Module im Umlauf.

# Beispielprogramm installieren
Nun installieren wird das erste Beispielprogramm auf dem rechten ESP32. Dazu wird der ESP32 mit USB verbunden und in der Arduino-IDE der neue serielle USB-Port ausgewählt. Dann in das Verzeichnis "NMEA2000-BME280-1" des heruntergeladenen und entpackten Reepositories wechseln und auf "NMEA2000-BME280-1.ino" doppelklicken.

Das Beispielprogramm ist nun in der Arduino-IDE geladen. Um es auf den ESP32 zu übertragen und zu starten wählen wir im Menü "Sketch" und dann "Hochladen". Das Programm wird nun übersetzt (kompiliert) und dann auf den ESP32 übertragen. Im unteren Statusfenster wird beim Übertragen "Connecting........_____....._____.." angezeigt. Normalerweise erfolgt das Hochladen nach ein paar Sekunden automatisch. Falls die Fehlermeldung "A fatal error occurred: Failed to connect to ESP32:" angezeigt wird, kann es helfen, während des Upload-Prozesses, die "Boot"-Taste gedrückt zu halten, bis der Upload-Prozess startet.

Sobald "Leaving...  Hard resetting via RTS pin..." angezeigt wird, ist das Beispielprogramm erfolgreich übertragen und auch schon gestartet worden.

Nun wollen wir sehen, ob alles funktioniert. Dazu wählen wir im Menü "Werkzeuge" und dann "Serieller Monitor". Die Baudrate (rechts unten im Fenster) setzen wir auf "115200 Baud".

Jetzt sollten wir mehrere Zeilen sehen, in denen die Temperatur angezeigt wird: "09:46:27.022 -> Temperature: 20.7 °C"

Falls keine Temperatur angezeigt wird, ist irgendwo ein Fehler passiert. Entweder in der Verkabelung oder das BME280-Modul nutzt eine abweichende Adresse für den I2C-Bus.

Beides müssen wir dann kontrollieren und beheben. Falls die Verkabelung OK ist, suchen wir im Programm die Zeile 63:

```
if (!bme.begin(0x76)) {
````

Den Wert "0x76" ersetzen wir dann mit "0x77". Danach den Sketch speichern und erneut hochladen.
Spätestens jetzt sollte im Seriellen Monitor die Temperatur angezeigt werden.

# Anzeige der NMEA2000-Daten mit dem NMEA-Reader
Im nächsten Shritt wollen wir sehen, ob unser kleines NMEA2000-Netzwerk auch funktioniert.

Mit dem NMEA-Reader können wir Daten vom NMEA2000-Netzwerk anzeigen. Dazu starten wir das zuvor installierte Programm "NMEAReader"
Im Reader wählen wir oben den zuvor notierten seriellen Port vom linken ESP32 aus und setzen auch hier die Baudrate auf 11520 Baud.

Die Anzeige sollte dann in etwa so aussehen:

![NMEReader-1](https://github.com/AK-Homberger/NMEA-Workshop/blob/main/Bilder/NMEAReader-1.png)

Eventuell ist beim ersten Mal die PGN-Zeile anzuwählen und rechts im Fenster der Reiter "Details" auszuwählen.

Wenn die Anzeige so aussieht, dann erst einmal "Herzlichen Glückwunsch"! Es funktioniert alles. Die Daten werden vom rechten Modul korrekt gesendet, unser NMEA2000-Bus funktioniert und das linke Modul hat die Daten korrekt empfangen. Der dort installierte (ActisenseListenerSender-ESP32) Sketch nimmt die Daten vom NMEA2000-Bus auf und sendet sie über die serielle Schnittstelle an das Programm NMEA-Reader. Das Programm dekodiert die Daten und zeigt sie an.

Doch was bedeutet die Anzeige?

- Wir sehen, dass PGN130312 empfangen wurde. Der Name ist "Temperature - DEPRECATED"
- Wir sehen auch die Uhrzeit und auch das Sendeinterval 1.00 (= 1 mal pro Sekunde)
- Es wurde die Souce Adresse (SRC) "34" vom sendenden Modul genutzt.
- Im rechten Fenster sehen wir Details. So wird in Feld 4 die Temperatur angezeigt (in Kelvin und auch in Grad Celsius).

# Struktur des Beispielprogramms

Das Beispielprogramm ist in der Programmierprache C und C++ geschrieben. Eine gutes Tutorial zur Programmiersprache ist übrigens [hier](https://www.w3schools.com/cpp/default.asp) zu finden.

Der Aufbau unserer Beispielprogramme in der Arduino-IDE ist im Prinzip immer gleich.

1. Include-Dateien (#include) für verwendete Komponenten und Bibliotheken
2. Definiton von Konstanten (#define)
3. Definition von globalen Variablen/Methoden
4. Funktion "setup()" zur Initialisierung (Baudrate usw.). Diese Funktion wird einmalig beim Start des Programms ausgeführt.
5. Notwendige Hilfsfunktionen
6. Funktion "loop()". Diese Funktion wird als Schleife immer wieder ausgeführt.

Kommen wir nun zum Inhalt unsere ersten Beispielprogramms:

# Include-Dateien und Definition von Konstanten

````
#define ESP32_CAN_TX_PIN GPIO_NUM_5  // Set CAN TX port to 5 
#define ESP32_CAN_RX_PIN GPIO_NUM_4  // Set CAN RX port to 4

#include <Arduino.h>
#include <Preferences.h>
#include <NMEA2000_CAN.h>  // This will automatically choose right CAN library and create suitable NMEA2000 object
#include <N2kMessages.h>

// Include files for BME280
#include <Wire.h>
#include <Adafruit_Sensor.h>
#include <Adafruit_BME280.h>
````
Als erstes sehen wir hier die Definition zweier Konstanten, welche die GPIO-Ports für CAN TX und CAN RX festlegen. Die Ports 5 und 4 sind die Ports, die wir auch auf dem Steckbrett verbunden haben. Die Definition muss hier vor den Include-Dateien für die NMEA2000-Biblitheken erfolgen, da die Werte dort zur Konfiguration genutzt werden.

Die oberen Include-Dateien sind für die generelle Funktion (Arduino.h) und für die Nutzung des permanenet Speichers ds ESP32 notwendig (Preferences.h).
Die folgenden beiden sind für die Nutzung der NMEA-Bibliotheken so notwendig.

Die folgenden drei Include-Dateien sind für die Nutzung der BME2800-Bibliothek notwendig.





